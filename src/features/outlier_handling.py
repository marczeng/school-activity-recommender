"""Utility helpers for robust, vectorised outlier handling.

The previous implementation mixed ad-hoc heuristics with brittle pandas
assignments.  The rewritten module keeps the public API identical but provides
clearer semantics, exhaustive docstrings and stricter handling of edge cases so
that the pipeline scripts remain reliable.
"""

from __future__ import annotations

from pathlib import Path
import json
from typing import Dict, Iterable, List, Tuple

import numpy as np
import pandas as pd

__all__ = [
    "select_numeric_continuous",
    "compute_iqr_thresholds",
    "winsorize_with_flags",
    "zscore_diagnostics",
    "save_report",
]


def _is_all_integers(series: pd.Series) -> bool:
    """Return ``True`` when every non-null value is an integer value."""

    non_null = series.dropna()
    if non_null.empty:
        return False
    if pd.api.types.is_integer_dtype(non_null):
        return True
    if pd.api.types.is_float_dtype(non_null):
        return np.isclose(non_null % 1, 0).all()
    return False


def select_numeric_continuous(df: pd.DataFrame) -> Tuple[List[str], List[str]]:
    """Split numeric columns into continuous and binary-like groups.

    ``*_raw`` and ``*_outlier_flag`` columns are considered technical columns
    generated by the winsorisation process and are ignored by default.
    """

    numeric_cols = df.select_dtypes(include="number").columns
    technical_suffixes: Tuple[str, ...] = ("_raw", "_outlier_flag")
    base_numeric = [c for c in numeric_cols if not c.endswith(technical_suffixes)]

    maybe_ids = [c for c in base_numeric if "id" in c.lower() and _is_all_integers(df[c])]
    binary_like = [c for c in base_numeric if df[c].dropna().isin([0, 1]).all()]

    excluded: set[str] = set(maybe_ids) | set(binary_like)
    continuous = [c for c in base_numeric if c not in excluded]
    return continuous, binary_like


def compute_iqr_thresholds(
    df: pd.DataFrame, cols: Iterable[str], iqr_eps: float = 1e-9
) -> Tuple[Dict[str, Dict[str, float]], pd.Series, pd.Series, pd.Series, pd.Series, pd.Series]:
    """Calculate the IQR-based clipping thresholds for a set of columns."""

    cols = list(cols)
    if not cols:
        empty = pd.Series(dtype=float)
        return {}, empty, empty, empty, empty, empty

    quantiles = df[cols].quantile([0.25, 0.75])
    q1, q3 = quantiles.loc[0.25], quantiles.loc[0.75]
    iqr = (q3 - q1).replace(0, iqr_eps)

    lower = q1 - 1.5 * iqr
    upper = q3 + 1.5 * iqr

    thresholds = {
        c: {
            "q1": float(q1[c]),
            "q3": float(q3[c]),
            "iqr": float(iqr[c]),
            "lower": float(lower[c]),
            "upper": float(upper[c]),
        }
        for c in cols
    }
    return thresholds, q1, q3, iqr, lower, upper


def winsorize_with_flags(df: pd.DataFrame, cols: Iterable[str], lower: pd.Series, upper: pd.Series) -> pd.DataFrame:
    """Return a copy of ``df`` with winsorised values and outlier flags."""

    cols = list(cols)
    if not cols:
        return df

    df = df.copy()
    raw_cols = {f"{c}_raw": df[c] for c in cols}
    for new_col, values in raw_cols.items():
        df[new_col] = values

    clipped = df[cols].clip(lower=lower, upper=upper, axis=1)
    flags = (df[cols].lt(lower) | df[cols].gt(upper)).astype(int)

    for col in cols:
        df[col] = clipped[col]
        df[f"{col}_outlier_flag"] = flags[col]

    return df


def zscore_diagnostics(df: pd.DataFrame, cols: Iterable[str]) -> Dict[str, float]:
    """Compute the proportion of observations with ``|z| > 3`` for each column."""

    stats: Dict[str, float] = {}
    for col in cols:
        raw_col = f"{col}_raw"
        base = df[raw_col] if raw_col in df.columns else df[col]
        std = base.std(ddof=0)
        if std and not pd.isna(std):
            z = (base - base.mean()) / std
            stats[col] = float((z.abs() > 3).mean())
        else:
            stats[col] = 0.0
    return stats


def save_report(
    path: Path,
    num_cols: List[str],
    q1: pd.Series,
    q3: pd.Series,
    iqr: pd.Series,
    lower: pd.Series,
    upper: pd.Series,
    z_rate: Dict[str, float],
    *,
    source: str,
    output: str,
) -> None:
    """Persist a JSON report describing the winsorisation process."""

    path.parent.mkdir(parents=True, exist_ok=True)
    report = {
        "method": "IQR winsorization with binary flags (vectorised)",
        "num_cols": num_cols,
        "iqr_thresholds": {
            "q1": q1.to_dict(),
            "q3": q3.to_dict(),
            "iqr": iqr.to_dict(),
            "lower": lower.to_dict(),
            "upper": upper.to_dict(),
        },
        "zscore_diagnostics": z_rate,
        "source": source,
        "output": output,
    }
    with open(path, "w", encoding="utf-8") as fh:
        json.dump(report, fh, ensure_ascii=False, indent=2)
